# Модуль 3, Урок 4: Доработка Dino 3D — Game Over, Restart, UI

**Цель урока:** собрать “игровой цикл” (start → play → game over → restart), добавить UI (очки/время), завершить Dino 3D и закрепить материал модуля (мини‑тесты).

---

Сейчас Dino 3D уже похож на игру, но у него нет главного: понятного финала.
Игрок должен понимать: “я проиграл”, “вот мой результат”, “вот как начать заново”.

---

Сегодня сделаем то, что отличает “демо” от “игры”: **Game Over**, **перезапуск** и **UI**.

---

## Теория 1: Что такое “состояние игры” (Game State)

Когда игра идёт, мы выполняем управление, спавн и счёт.
Когда игра окончена, это должно остановиться.

Для этого удобно держать булевую переменную:

```csharp
bool isGameOver;
```

И использовать её как “переключатель”:

- если `isGameOver == true` → показываем UI Game Over, блокируем управление
- если `isGameOver == false` → игра работает

---

```quiz
id: l2m3y4-q-isgameover-meaning
kind: single
text: Зачем нужен флаг isGameOver?
answers:
  - text: Чтобы одним переключателем останавливать игровые действия при проигрыше
    correct: true
  - text: Чтобы ускорять физику
  - text: Чтобы хранить позицию игрока
```

---

## Пояснение

- `isGameOver` помогает не запускать управление/спавн/счёт, когда игра окончена.

---

```quiz
id: l2m3y4-q-game-flow
kind: single
text: Какой порядок правильнее для обычной игры?
answers:
  - text: Start → Play → Game Over → Restart
    correct: true
  - text: Restart → Game Over → Start → Play
  - text: Play → Start → Restart → Game Over
```

---

## Пояснение

- Обычно игра начинается, идёт, заканчивается, и потом игрок запускает заново.

---

## Практика 1: Мини‑повторение (Quiz)

### Часть 1: Проверка знаний (Quiz)

```quiz
id: l2m3y4-p1-q-raycast-purpose
kind: single
text: Зачем мы делали Raycast вниз в DinoController?
answers:
  - text: Чтобы понять, на земле ли игрок (и разрешать прыжок)
    correct: true
  - text: Чтобы рисовать UI
  - text: Чтобы увеличить скорость
```

---

## Ответы: Практика 1 (Quiz)

- Raycast вниз — чтобы получить `isGrounded`.

---

```quiz
id: l2m3y4-p1-q-and-vs-or
kind: single
text: Какой оператор означает “ИЛИ” (достаточно одного условия)?
answers:
  - text: &&
  - text: ||
    correct: true
  - text: ==
```

---

## Ответы: Практика 1 (Quiz) — продолжение

- `||` — логическое ИЛИ.

---

### Часть 2: Маленькая тренировка в коде

**Задача:**

1. Создайте скрипт `GameStateDemo.cs`.
2. Сделайте `bool isGameOver = false;`
3. В `Start()` выведите в консоль:
   - если `isGameOver` → “Экран Game Over”
   - иначе → “Играем”

```check
rules:
  - filename: "GameStateDemo.cs"
  - contains: "bool isGameOver"
  - contains: "if ("
  - contains: "else"
  - contains: "Debug.Log"
```

---

## Перерыв

---

UI — это то, что игрок видит: очки, время, кнопки.
Сейчас подключим TextMeshPro и сделаем экран Game Over.

---

## Теория 2: Перезапуск сцены и UI

Перезапуск игры чаще всего делают через перезагрузку текущей сцены:

```csharp
SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);
```

Для этого нужен `using UnityEngine.SceneManagement;`.

UI обычно обновляют каждый кадр или по событию, например:

```csharp
scoreText.text = score.ToString();
```

---

```quiz
id: l2m3y4-q-restart-api
kind: single
text: Каким методом чаще всего перезапускают текущую сцену?
answers:
  - text: SceneManager.LoadScene(...)
    correct: true
  - text: Destroy(Scene)
  - text: GameObject.Restart()
```

---

## Пояснение

- Перезапуск через `SceneManager.LoadScene` — самый простой и надёжный способ для курса.

---

```quiz
id: l2m3y4-q-ui-text-type
kind: single
text: Какой компонент чаще всего используют для текста в UI (в наших уроках)?
answers:
  - text: TMP_Text (TextMeshPro)
    correct: true
  - text: Rigidbody
  - text: Collider
```

---

## Пояснение

- Для текста мы используем TextMeshPro (`TMP_Text`).

---

## Практика 2: Применение в игре — GameController + UI + Restart (заготовка)

### Шаг 1: UI на сцене

1. Создайте `Canvas`.
2. Добавьте текст `ScoreText` (TextMeshPro).
3. Создайте панель `GameOverPanel` и выключите её (`SetActive(false)`).
4. Добавьте на панель кнопку `RestartButton`.

```check
rules:
  - object_exists: "Canvas"
  - object_exists: "GameOverPanel"
  - object_exists: "RestartButton"
```

---

### Шаг 2: `GameController.cs` — хранит счёт и Game Over

**Задача (заготовка):**

1. Создайте `GameController.cs` и объект `GameController` на сцене.
2. Добавьте поля:
   - `public bool isGameOver;`
   - `public TMP_Text scoreText;`
   - `public GameObject gameOverPanel;`
3. Добавьте `public void GameOver()`:
   - `isGameOver = true;`
   - `gameOverPanel.SetActive(true);`
4. Добавьте `public void Restart()`:
   - перезагрузить сцену

```check
rules:
  - filename: "GameController.cs"
  - contains: "public bool isGameOver"
  - contains: "void GameOver()"
  - contains: "gameOverPanel.SetActive(true)"
  - contains: "void Restart()"
  - contains: "SceneManager.LoadScene"
```

---

### Шаг 3: Связь препятствия с Game Over (вынести из Debug.Log)

В `ObstacleTrigger.cs` вместо `Debug.Log` нужно вызывать `GameOver()` у контроллера.

Подсказка: можно найти контроллер так:

```csharp
FindFirstObjectByType<GameController>()
```

```check
rules:
  - filename: "ObstacleTrigger.cs"
  - contains: "GameOver"
```

---

### Шаг 4: Блокируем управление при Game Over

В `DinoController.cs` добавьте проверку: если `isGameOver`, то прыжок/движение не выполняются.

```check
rules:
  - filename: "DinoController.cs"
  - contains: "isGameOver"
```

---

### Шаг 5: Кнопка Restart

В инспекторе у `RestartButton` в `OnClick` привяжите метод `GameController.Restart()`.

---

## Итоги

На уроке мы:

- добавили состояние игры (Game Over) и научились “останавливать” логику
- сделали UI: счёт и экран Game Over
- добавили перезапуск сцены через `SceneManager.LoadScene`
- завершили Dino 3D и закрепили темы модуля 3

